/*

  Redux!
  The Power of Three: state, action, reducer!

  Author: https://twitter.com/dan_abramov

  Принципы Redux.

  state = {
    popup: false
  }

  state.popup = true;





  
  1. Первый принцип (State)
  Не зависимо от того, насколько простым или сложным является ваше приложение. Будь то простой счетчик,
  или приложение с большим колчичеством сложного пользовательского интерфейса - вы описываете все состояние
  вашего приложения, при помощи одного JavaScript обьекта (state).

  Все изменения состояния являются явными, то есть можно отследить каждый из них.
  Все данные, а так же состояние UI которое изменяются хранятся в одном обьекте, который и
  называется состоянием state! (Или древом состояния - state tree)


  2. Второй принцип (Actions и неизменность State)
  Объект состояния, доступен только для чтения. Мы не можем изменить или записать в него что-то напрямую.
  Действия (actions) являются простыми js объектами. Структуру объекта действия мы определяем сами,
  едминственное условие, которое мы должны выолнить - action должен иметь одно свойство которое не будет undefined.
  (Обычно наименование Action).
  Не зависимо от того, как данные попадают в приложение, будь это - сетевой запрос или изменение UI,
  единственный спостоб доставить эти данные в store, использовать action!

  - Иногда в интернете можно встретить термин "Single source of truth", или "Однонаправленный поток данных"
    который как раз описывает поведение State в Redux.
    Этот подход дает нам возможнсть быстро получать информацию и поддерживать структуру состояния нашего
    приложения в "чистом" виде и безболезненно раширять наше приложение.

    В противовес можно показать Flux который имеет точно такой же принцип работы (Action->Dispatcher->Store->View);
    Но при этом имеет возможность создавать множественные Store, и данные в компонент могут приходить с разных store.

  2.5 -> Pure and Impure functions (PURE_and_UNPURE_functions.js);

  3. Третий принцип (Reducer)
  Уровень представления или наш UI наиболее предсказуем, когда описывается в виде чистой функции состояния.
  Такой подход впервые был реализован в Реакте, но после был подхвачен другими фреймворками, например Angular, Ember, Vue.

  Redux дополняет этот подход. Все мутации нашего состояния описываются как чистые функции, которые принимают
  предыдущее состояние (previous state) нашего приложения и отправленное действие (action), возвращая
  следующее состояние нашего приложения.

  Что бы описать изменения нашего состояния, мы должны вызвать специальную функцию, которая принимает
  предыдущее состояние приложения, отправленный action и возвращает соедующее состояние.
  Эта функция называется Редюсером (Reducer)

*/
